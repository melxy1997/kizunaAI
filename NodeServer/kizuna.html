<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="utf-8">
	<style type="text/css">
		body {
			margin: 0;
			background-color: #000;
			color: #fff;
			font-family: Monospace;
			font-size: 13px;
			line-height: 24px;
			overscroll-behavior: none;
		}

		canvas {
			display: block;
		}
	</style>
</head>

<body>
	<script src="https://cdn.jsdelivr.net/npm/socket.io-client@3.1.0/dist/socket.io.min.js"></script>

	<script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r123/examples/js/libs/ammo.wasm.js"></script>

	<script src='./gif/gif.js'></script>
	<script>
		let res_count = -1;
		const MAX_NUM_FRAME = 5;

		function createGIFobj() {
			let gif = new GIF({
				workers: 2,
				quality: 10,
				workerScript: './gif/gif.worker.js'
			});

			gif.on('finished', function (blob) {
				console.log("GIF录制完成");
				let url = URL.createObjectURL(blob);
				console.log("blob",blob);
				console.log("url", url);
			});

			return gif;
		}

		let gif_obj = createGIFobj();
		
	</script>
	<script type="module">
		

		import * as THREE from 'https://cdn.jsdelivr.net/gh/mrdoob/three.js@r123/build/three.module.js';

		import Stats from 'https://cdn.jsdelivr.net/gh/mrdoob/three.js@r123/examples/jsm/libs/stats.module.js';

		import { OutlineEffect } from 'https://cdn.jsdelivr.net/gh/mrdoob/three.js@r123/examples/jsm/effects/OutlineEffect.js';
		import { MMDLoader } from 'https://cdn.jsdelivr.net/gh/mrdoob/three.js@r123/examples/jsm/loaders/MMDLoader.js';
		import { MMDAnimationHelper } from 'https://cdn.jsdelivr.net/gh/mrdoob/three.js@r123/examples/jsm/animation/MMDAnimationHelper.js';

		let container, stats, helper;
		let mesh, camera, scene, renderer, effect;
		let head, left_eye, right_eye;
		let angle_const = 3.1415926 / 180;

		let socket = io("http://127.0.0.1:6789/kizuna");
		let websocketClose = () => socket.close();

		socket.on('result_download', (result) => {
			// console.log('Kizuna.html receive:', result);
			requestAnimationFrame(() => animate(result));
		});

		let clock = new THREE.Clock();

		

		Ammo().then(function (AmmoLib) {

			setTimeout(function () {
				// 30 25 24 21 20 19 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0

				// happy_eye_close: 0, 2, 3
				// neutral_eye_close: 1, 4, 5
				// blink: none -> 6 -> 1 -> 7 -> 8 -> none

				// mouth: 9 -> 13 -> 14 -> 12 -> 16 -> 17 -> 11
				// teeth: 10 15 21
				// happy: 18 23
				// unhappy: 19 24 25
				// what?: 20

				requestAnimationFrame(() => animate({ 'euler': [0, 0, 0], 'eye': [0, 0] }));
			}, 2000);

			init();
		});


		function init() {

			container = document.createElement('div');
			document.body.appendChild(container);

			camera = new THREE.PerspectiveCamera(20, window.innerWidth / window.innerHeight, 1, 100);
			camera.position.set(0, 0, 16);

			// scene

			scene = new THREE.Scene();
			// scene.background = new THREE.Color(0x000000); // 0xffffff

			let ambient = new THREE.AmbientLight(0x666666);
			scene.add(ambient);

			let directionalLight = new THREE.DirectionalLight(0x887766);
			directionalLight.position.set(- 1, 1, 1).normalize();
			scene.add(directionalLight);

			renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			container.appendChild(renderer.domElement);

			effect = new OutlineEffect(renderer);

			// STATS

			stats = new Stats();
			container.appendChild(stats.dom);

			// model

			function onProgress(xhr) {

				if (xhr.lengthComputable) {
					let percentComplete = xhr.loaded / xhr.total * 100;
					console.log(Math.round(percentComplete, 2) + '% downloaded');
				}
			}

			let modelFile = 'models/kizunaai/kizunaai.pmx';

			helper = new MMDAnimationHelper({ afterglow: 0.0 });

			new MMDLoader().load(modelFile, function (object) {

				mesh = object;
				mesh.position.y = -18;

				scene.add(mesh);

				helper.add(mesh, { physics: true });

				let ikHelper = helper.objects.get(mesh).ikSolver.createHelper();
				ikHelper.visible = false;
				scene.add(ikHelper);

				let physicsHelper = helper.objects.get(mesh).physics.createHelper();
				physicsHelper.visible = false;
				scene.add(physicsHelper);

				let bones = physicsHelper.physics.mesh.skeleton.bones;

				head = bones[8];
				left_eye = bones[86];
				right_eye = bones[88];

			}, onProgress, null);

			window.addEventListener('resize', onWindowResize, false);
		}

		function onWindowResize() {

			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			effect.setSize(window.innerWidth, window.innerHeight);

		}

		

		function animate(result) {

			stats.begin();
			render(result);
			res_count += 1
			// console.log("res_count:",res_count);
			// console.log("In function animate:", result);
			/*在此处创建gif帧*/
			let canvas = document.querySelector('canvas');
			gif_obj.addFrame(canvas, {delay: 200});

			if(res_count!=0 && res_count%MAX_NUM_FRAME == 0){
				gif_obj.render();
				console.log("帧数达到周期数，render()");
				console.log("gif_obj", gif_obj);

				// gif_obj = createGIFobj()
			}
			stats.end();

		}

		function render(result) {

			let euler = result.euler;
			let eye_euler = result.eye;
			let mouth = result.mouth;
			let blink = result.blink;

			if (head) {
				head.rotation.x = Math.round(euler[0]) * angle_const;
				head.rotation.y = Math.round(euler[1]) * angle_const;
				head.rotation.z = Math.round(euler[2]) * angle_const;
			}

			if (left_eye) {
				left_eye.rotation.y = eye_euler[0];
				left_eye.rotation.x = eye_euler[1];
			}
			if (right_eye) {
				right_eye.rotation.y = eye_euler[0];
				right_eye.rotation.x = eye_euler[1];
			}

			let mouth_index, eye_index;

			if (mouth > 0.6) mouth_index = 9;
			else if (mouth > 0.4) mouth_index = 12;
			else if (mouth > 0.2) mouth_index = 11;

			if (blink) {
				if (blink[0] < 0.1 && blink[1] < 0.1) eye_index = 1;
				else if (blink[0] < 0.1) eye_index = 4;
				else if (blink[1] < 0.1) eye_index = 5;
			}

			if (mouth_index) {
				mesh.morphTargetInfluences[mouth_index] = 1;
			}

			if (eye_index) {
				mesh.morphTargetInfluences[eye_index] = 1;
			}

			helper.update(clock.getDelta());
			effect.render(scene, camera);

			if (mouth_index) {
				mesh.morphTargetInfluences[mouth_index] = 0;
			}

			if (eye_index) {
				mesh.morphTargetInfluences[eye_index] = 0;
			}
		}

	</script>

<script>
	/*
    // let isWorking = false;
    const gifRender = function() {
		console.log("function gifRender");
    //   if (isWorking) return;
    //   isWorking = true;
      let gif = new GIF({
        workers: 2,
        quality: 10,
        workerScript: './gif/gif.worker.js'
	  });

	  console.log("GIF_obj", gif);

	  let canvas = document.querySelector('canvas');

	  gif.addFrame(canvas, {delay: 200});
	  gif.render();

      gif.on('finished', function (blob) {
		// isWorking = false;
		
        let url = URL.createObjectURL(blob);

        console.log("blob",blob);
		console.log("url", url);
		
      });

      // let pic = new Pic(200, 200, 20, 10);
      // let renderFinished = false;
    //   function addFrame(canvas) {
    //     if (renderFinished) return;

    //     if (gif.frames.length < 50) {
    //       gif.addFrame(canvas, {delay: 20});
    //     } else {
    //       gif.render();
    //       renderFinished = true
    //       addFrame = null
    //     }
    //   }
      // Pic.draw(pic, addFrame);
	}
	*/
</script>

</body>

</html>